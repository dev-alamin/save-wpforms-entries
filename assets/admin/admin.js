// FEM_I18N: The global object containing all translatable strings.
// This object is generated by wp_localize_script in PHP.
// Example content: femStrings = { "csvExportedSuccess": "CSV exported successfully!", ... }

function formTable(form) {
  return {
    open: false,
    formId: form.form_id,
    formTitle: form.form_title,
    totalEntries: form.entry_count,
    entries: [],
    currentPage: 1,
    pageSize: femSettings.perPage,
    totalPages: 1,
    sortAsc: true,
    sortAscStatus: true,
    dateFrom: "",
    dateTo: "",
    loading: false,
    jumpTo: 1,
    noteOpen: false,
    bulkSelected: [],
    selectAll: false,
    lastCheckedIndex: null,
    chosenFields: [],

    // New property to store the complete fields schema from the API
    allFields: [],

    dropdownOpen: false,
    types: [
      { key: "email", label: searchDropdownString.emailLabel },
      { key: "name", label: searchDropdownString.nameLabel },
      { key: "id", label: searchDropdownString.entryIdLabel },
    ],

    entryModalOpen: false,
    selectedEntry: {},
    bgClasses: ["fem-row-bg-1", "fem-row-bg-2", "fem-row-bg-3", "fem-row-bg-4"],

    searchQuery: "",
    searchType: "email",
    filterStatus: "all",
    onlyFavorites: false,
    dateFrom: "",
    dateTo: "",
    customColumns: {},

    get paginatedEntries() {
      return this.entries;
    },

    get gridStyle() {
    let columns = ["50px", "1fr"];

    // Add a fixed width for each field in the chosenFields array
    // The number of columns now directly corresponds to the number of chosen fields
    this.chosenFields.forEach(() => {
        columns.push("150px"); 
    });

    // Add fixed columns for Date, Status, and Actions
    columns.push("150px", "150px", "250px");

    return columns.join(" ");
    },

    // Method to get the fields that should be displayed as columns
    get displayedFields() {
      const formId = this.formId; // Assuming formId is available in this scope

      // Get the list of selected field keys for the current form
      const selectedKeys = this.customColumns[formId] || [];

      // If there are no custom columns set, return all fields
      if (selectedKeys.length === 0) {
        return this.allFields;
      }

      // Otherwise, filter allFields to only include the selected ones
      return this.allFields.filter((field) => selectedKeys.includes(field.key));
    },

    getEntryData(entry, key) {
      return entry[key] || "-";
    },

    async performBulkAction(action) {
      if (!this.bulkSelected.length) return;

      try {
        if (action === "export_csv") {
          const res = await fetch(
            `${femSettings.restUrl}fem/v1/export/bulk`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-WP-Nonce": femSettings.nonce,
              },
              body: JSON.stringify({
                ids: this.bulkSelected,
              }),
            }
          );

          const blob = await res.blob();
          const url = window.URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = `fem-entries-${Date.now()}.csv`;
          document.body.appendChild(a);
          a.click();
          a.remove();

          window.URL.revokeObjectURL(url);

          this.$dispatch("toast", {
            type: "success",
            // FEM_I18N: Use translatable string
            message: femStrings.csvExportedSuccess,
          });
        } else {
          // Handle other actions
          const uniqueIds = [...new Set(this.bulkSelected)];

          const res = await fetch(
            `${femSettings.restUrl}fem/v1/entries/bulk`,
            {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
                "X-WP-Nonce": femSettings.nonce,
              },
              body: JSON.stringify({
                ids: uniqueIds,
                action,
              }),
            }
          );

          const data = await res.json();

          this.bulkSelected = [];
          this.selectAll = false;

          this.fetchEntries();

          if (action === "delete") {
            this.entries = this.entries.filter(
              (e) => !uniqueIds.includes(e.id)
            );

            this.$dispatch("toast", {
              type: "success",
              // FEM_I18N: Use translatable string
              message: data.message,
            });
          } else {
            // For other actions
            this.$dispatch("toast", {
              type: "success",
              // FEM_I18N: Use translatable string
              message: data.affected,
            });
          }
        }
      } catch (error) {
        console.error("Bulk action failed:", error);
        // FEM_I18N: Use translatable string
        this.$dispatch("toast", {
          type: "error",
          message: femStrings.bulkActionFailed + " " + error.message,
        });
      }
    },

    handleCheckbox(event, entryId) {
      const index = this.entries.findIndex((e) => e.id === entryId);
      if (index === -1) return;

      if (event.shiftKey && this.lastCheckedIndex !== null) {
        const start = Math.min(index, this.lastCheckedIndex);
        const end = Math.max(index, this.lastCheckedIndex);

        for (let i = start; i <= end; i++) {
          const id = this.entries[i].id;
          if (!this.bulkSelected.includes(id)) {
            this.bulkSelected.push(id);
          }
        }
      } else {
        const i = this.bulkSelected.indexOf(entryId);
        if (i > -1) {
          this.bulkSelected.splice(i, 1);
        } else {
          this.bulkSelected.push(entryId);
        }
      }

      this.lastCheckedIndex = index;
    },

    async fetchEntries() {
      this.loading = true;

      const query = new URLSearchParams({
        form_id: this.formId,
        page: this.currentPage,
        per_page: this.pageSize,
      });

      if (this.searchQuery.trim() !== "") {
        query.append("search", this.searchQuery.trim());
        query.append("search_type", this.searchType);
      }

      if (this.filterStatus !== "all") {
        query.append("status", this.filterStatus);
      }

      if (this.dateFrom) {
        query.append("date_from", this.dateFrom);
      }

      if (this.dateTo) {
        query.append("date_to", this.dateTo);
      }

      try {
        const res = await fetch(
          `${femSettings.restUrl}fem/v1/entries?${query}`,
          {
            headers: {
              "X-WP-Nonce": femSettings.nonce,
            },
          }
        );
        const apiResponse = await res.json();

        // Set the fields schema based on the API response
        this.allFields = apiResponse.entry_schema;

        // Tweak starts here
        // Get the form's user choices from the provided data
        const formChoices = femSettings.initialColumns[this.formId] || [];;

        // Map the chosen labels to their corresponding field objects using a case-insensitive comparison
        this.chosenFields = formChoices.map(label => {
        // Use .toLowerCase() on both sides for the comparison
        const normalizedLabel = label.toLowerCase();
        return this.allFields.find(field => field.label.toLowerCase() === normalizedLabel);
        }).filter(field => field !== undefined);

        // Set the entries directly from the API response
        this.entries = apiResponse.entries;
        // console.log('Fetched entries:', this.entries);

        this.totalEntries = Number(apiResponse.total) || this.entries.length;
        this.totalPages = Math.ceil(this.totalEntries / this.pageSize);
      } catch (error) {
        console.error(femStrings.fetchEntriesError, error);
      } finally {
        this.loading = false;
      }
    },

    // Filter and pagination handlers, now correctly calling the new fetchEntries
    handleSearchInput: _.debounce(function () {
      this.currentPage = 1;
      this.fetchEntries();
    }, 500),

    handleStatusChange() {
      this.currentPage = 1;
      this.fetchEntries();
    },

    handleDateChange() {
      this.currentPage = 1;
      this.fetchEntries();
    },
    toggleSelectAll(event) {
      if (event.target.checked) {
        this.bulkSelected = this.paginatedEntries.map((entry) => entry.id);
      } else {
        this.bulkSelected = [];
      }
    },
    toggleOpen() {
      this.open = !this.open;
      if (this.open && this.entries.length === 0) {
        this.fetchEntries();
      }
    },
    goToPage(page) {
      page = Number(page);
      if (page > 0 && page <= this.totalPages) {
        this.currentPage = page;
        this.fetchEntries();
      }
    },
    nextPage() {
      if (this.currentPage < this.totalPages) {
        this.currentPage++;
        this.fetchEntries();
      }
    },
    prevPage() {
      if (this.currentPage > 1) {
        this.currentPage--;
        this.fetchEntries();
      }
    },
    sortByDate() {
      this.entries = [...this.entries].sort((a, b) => {
        return this.sortAsc
          ? new Date(a.date) - new Date(b.date)
          : new Date(b.date) - new Date(a.date);
      });
      this.sortAsc = !this.sortAsc;
    },
    sortByStatus() {
      this.entries.sort((a, b) => {
        if (a.status === b.status) return 0;

        if (this.sortAscStatus) {
          return a.status === "unread" ? -1 : 1;
        } else {
          return a.status === "read" ? -1 : 1;
        }
      });

      this.sortAscStatus = !this.sortAscStatus;
    },
    showEntry(i) {
      const entry = this.entries[i];
      this.selectedEntry = entry;
      this.entryModalOpen = true;

      if (entry.status === "unread") {
        entry.status = "read";
        this.updateEntry(i, {
          status: "read",
        });
      }
    },

    markAs(status) {
      if (!this.entryModalOpen) return;
      this.selectedEntry.status = status;
      this.entryModalOpen = false;
    },

    copied: false,

    copyEntryToClipboard() {
        const entry = this.selectedEntry.entry || {};
        const name = this.selectedEntry.name || "-";
        const email = this.selectedEntry.email || "-";

        // Start with name and email on top
        const topLines = [`Name: ${name}`, `Email: ${email}`];

        // Add the rest of the entry, excluding name/email if they exist in entry
        const otherLines = Object.entries(entry)
            .filter(([key]) => key.toLowerCase() !== "name" && key.toLowerCase() !== "email")
            .map(([key, value]) => `${key}: ${value || "-"}`);

        const lines = [...topLines, ...otherLines].join("\n");

        navigator.clipboard
            .writeText(lines)
            .then(() => {
                this.copied = true;
                setTimeout(() => {
                    this.copied = false;
                }, 2000);
            })
            .catch((err) => {
                console.error("Copy failed:", err);
            });
    },

    async updateEntry(index, changes = {}) {
      const entry = this.entries[index];

      const payload = {
        id: entry.id,
        form_id: entry.form_id,
        entry: entry.entry,
        status: entry.status,
        is_favorite: Number(entry.is_favorite),
        note: entry.note,
        exported_to_csv: Number(entry.exported_to_csv),
        synced_to_gsheet: Number(entry.synced_to_gsheet),
        printed_at: entry.printed_at,
        resent_at: entry.resent_at,
        ...changes,
      };

      try {
        const res = await fetch(
          `${femSettings.restUrl}fem/v1/entries/${
            payload.id
          }?form_id=${encodeURIComponent(payload.form_id)}`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-WP-Nonce": femSettings.nonce,
            },
            body: JSON.stringify(payload),
          }
        );

        const data = await res.json();
      } catch (error) {
        console.error("Failed to update entry:", error);
      }
    },

    async deleteEntry() {
      if (!this.selectedEntry) return;

      try {
        const response = await fetch(
          `${femSettings.restUrl}fem/v1/entries/${
            this.selectedEntry.id
          }?form_id=${encodeURIComponent(this.selectedEntry.form_id)}`,
          {
            method: "DELETE",
            headers: {
              "Content-Type": "application/json",
              "X-WP-Nonce": femSettings.nonce,
            },
          }
        );

        const data = await response.json();

        if (data.deleted) {
          // Close the modal and reset the selected entry immediately
          this.entryModalOpen = false;
          this.selectedEntry = null;

          // This is the single, bulletproof line to refresh the UI.
          // It fetches the latest data from the server, which is the single source of truth.
          this.fetchEntries();

          // Dispatch a success toast message
          this.$dispatch("toast", {
            type: "success",
            message: data.message,
          });
        } else {
          // The API returned an error message
          this.$dispatch("toast", {
            type: "error",
            message: femStrings.deleteFailedUnknown.replace(
              "Unknown error",
              data.message || "Unknown error"
            ),
          });
        }
      } catch (error) {
        // A network or other fetch error occurred
        this.$dispatch("toast", {
          type: "error",
          message: femStrings.deleteRequestFailed,
        });
        console.error("Delete request failed:", error);
      }
    },

    toggleFavorite(index) {
      const entry = this.entries[index];
      entry.is_favorite = entry.is_favorite === 1 ? 0 : 1;
      this.updateEntry(index, {
        is_favorite: entry.is_favorite,
      });
    },
    toggleRead(index) {
      const entry = this.paginatedEntries[index];
      entry.status = entry.status === "unread" ? "read" : "unread";
      this.updateEntry(index, {
        status: entry.status,
      });
    },
    toggleModalReadStatus() {
      const entry = this.selectedEntry;
      const newStatus = entry.status === "unread" ? "read" : "unread";
      entry.status = newStatus;

      const index = this.entries.findIndex((e) => e.id === entry.id);
      if (index !== -1) {
        this.entries[index].status = newStatus;
        this.updateEntry(index, {
          status: newStatus,
        });
      }
    },
    async updateSelectedEntry(changes = {}) {
      const entryId = this.selectedEntry.id;

      const index = this.entries.findIndex((e) => e.id === entryId);
      if (index === -1) {
        // FEM_I18N: Use translatable string
        console.error(femStrings.entryNotFound);
        return;
      }

      // Merge changes into selectedEntry
      Object.assign(this.selectedEntry, changes);

      const payload = {
        id: this.selectedEntry.id,
        form_id: this.selectedEntry.form_id,
        entry: this.selectedEntry.entry,
        status: this.selectedEntry.status,
        is_favorite: Number(this.selectedEntry.is_favorite),
        note: this.selectedEntry.note,
        exported_to_csv: Number(this.selectedEntry.exported_to_csv),
        synced_to_gsheet: Number(this.selectedEntry.synced_to_gsheet),
        printed_at: this.selectedEntry.printed_at,
        resent_at: this.selectedEntry.resent_at,
      };

      try {
        const res = await fetch(
          `${femSettings.restUrl}fem/v1/entries/${
            payload.id
          }?form_id=${encodeURIComponent(payload.form_id)}`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-WP-Nonce": femSettings.nonce,
            },
            body: JSON.stringify(payload),
          }
        );

        const data = await res.json();

        this.$dispatch("toast", {
          type: "success",
          // FEM_I18N: Use translatable string
          message: femStrings.changesSavedSuccess,
        });

        window.dispatchEvent(new CustomEvent("note-saved"));

        this.entries[index] = { ...this.selectedEntry };
      } catch (err) {
        // FEM_I18N: Use translatable string
        console.error(femStrings.saveFailed, err);
      }
    },
    validateAndSaveNote() {
      const note = this.selectedEntry.note?.trim() || "";

      if (note.length > 1000) {
        // FEM_I18N: Use translatable string
        alert(femStrings.noteTooLong);
        return;
      }

      this.updateSelectedEntry({
        note,
      });
    },
   async toggleGoogleSheetSync(index) {
    const entry = this.entries[index];
    const entryId = entry.id;
    const nonce = femSettings.nonce;

    const isCurrentlySynced = !!entry.synced; // use consistent property
    const action = isCurrentlySynced ? "unsync" : "sync";
    const apiUrl = `${femSettings.restUrl}fem/v1/entries/${entryId}/${action}`;

    try {
        const response = await fetch(apiUrl, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
            "X-WP-Nonce": nonce,
        },
        });

        if (!response.ok) {
        throw new Error(`Request failed: ${response.status}`);
        }

        const data = await response.json();

        if (data.success) {
        window.dispatchEvent(new CustomEvent("toast", {
            detail: {
            message: femStrings.syncDone,
            type: "success",
            },
        }));
        } else {
        window.dispatchEvent(new CustomEvent("toast", {
            detail: {
            message: femStrings.syncFailed + " " + (data?.message || ""),
            type: "error",
            },
        }));
        }

        // Update local entry state
        entry.synced = isCurrentlySynced ? 0 : 1;
        this.updateEntry(index, { synced_to_gsheet: entry.synced });

    } catch (error) {
        console.error("Fetch Error:", error);
        alert(femStrings.networkError);
    }
    },

    printEntry(index) {
      const entry = this.entries[index];
      const formTitle = entry.form_title || "Form Entry";

      entry.printed_at = new Date()
        .toISOString()
        .slice(0, 19)
        .replace("T", " ");
      this.updateEntry(index, {
        printed_at: entry.printed_at,
      });

    const entryData = entry.entry || {};
    const name = entry.name || "-";
    const email = entry.email || "-";

    // Start with name and email on top
    const topFields = [
        {
            key: "Name",
            value: name
        },
        {
            key: "Email",
            value: email
        }
    ];

    // Add the rest of the entry, excluding name/email if they exist in entryData
    const otherFields = Object.entries(entryData)
        .filter(([key]) => key.toLowerCase() !== "name" && key.toLowerCase() !== "email")
        .map(([key, value]) => ({ key, value }));

    const allFields = [...topFields, ...otherFields];

    const formattedFields = allFields
        .map(({ key, value }) => `
            <div style="margin-bottom: 16px;">
                <div style="font-weight: 600; font-size: 15px; color: #2d3748;">${key}</div>
                <div style="margin-top: 4px; font-size: 14px; color: #1a202c;">${value || "-"}</div>
                <hr style="border-top: 1px dashed #ddd; margin-top: 10px;" />
            </div>
        `)
        .join("");


      const printWindow = window.open("", "", "width=1000,height=700");
      printWindow.document.write(`
                <html>
                <head>
                    <title>${formTitle} - Entry Details</title>
                    <style>
                        body {
                            font-family: 'Segoe UI', Tahoma, sans-serif;
                            padding: 30px;
                            background: #f3f4f6;
                        }
                        .entry-box {
                            max-width: 800px;
                            margin: auto;
                            background: white;
                            padding: 40px;
                            border-radius: 10px;
                            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
                        }
                        .entry-header {
                            font-size: 24px;
                            font-weight: bold;
                            text-align: center;
                            color: #1a202c;
                            margin-bottom: 30px;
                            border-bottom: 2px solid #e2e8f0;
                            padding-bottom: 10px;
                        }
                    </style>
                </head>
                <body>
                    <div class="entry-box">
                        <div class="entry-header">${formTitle}</div>
                        ${formattedFields}
                    </div>
                </body>
                </html>
            `);
      printWindow.document.close();
      printWindow.focus();
      printWindow.print();
    },
    exportSingleEntry(entry) {
      const csvContent =
        `"Field","Value"\n` +
        Object.entries(entry.entry)
          .map(
            ([key, val]) =>
              `"${key.replace(/\r?\n|\r/g, " ")}","${(val ?? "")
                .toString()
                .replace(/"/g, '""')}"`
          )
          .join("\n");

      const blob = new Blob([csvContent], {
        type: "text/csv;charset=utf-8;",
      });
      const link = document.createElement("a");
      link.href = URL.createObjectURL(blob);
      link.download = `entry-${entry.id}.csv`;
      link.click();
    },
    timeAgo(dateString) {
      const utcDateString = dateString.replace(" ", "T") + "Z";
      const date = new Date(utcDateString);
      const now = new Date();
      const seconds = Math.floor((now - date) / 1000);

      if (seconds < 60) return femStrings.timeAgoJustNow;
      if (seconds < 3600)
        return femStrings.timeAgoMinutes.replace(
          "%d",
          Math.floor(seconds / 60)
        );
      if (seconds < 86400)
        return femStrings.timeAgoHours.replace(
          "%d",
          Math.floor(seconds / 3600)
        );

      const yesterday = new Date();
      yesterday.setDate(now.getDate() - 1);

      if (
        date.getDate() === yesterday.getDate() &&
        date.getMonth() === yesterday.getMonth() &&
        date.getFullYear() === yesterday.getFullYear()
      ) {
        return femStrings.timeAgoYesterday;
      }

      const optionsSameYear = {
        day: "numeric",
        month: "long",
      };
      const optionsLastYear = {
        day: "numeric",
        month: "long",
        year: "numeric",
      };
      const isThisYear = now.getFullYear() === date.getFullYear();

      return date.toLocaleDateString(
        "en-US",
        isThisYear ? optionsSameYear : optionsLastYear
      );
    },
    get visiblePages() {
      const pages = [];
      const delta = 2;
      const range = [];
      const total = this.totalPages;
      const current = this.currentPage;

      const left = current - delta;
      const right = current + delta;

      for (let i = 1; i <= total; i++) {
        if (i === 1 || i === total || (i >= left && i <= right)) {
          range.push(i);
        }
      }

      let lastPage = 0;
      for (let page of range) {
        if (lastPage && page - lastPage > 1) {
          pages.push("...");
        }
        pages.push(page);
        lastPage = page;
      }

      return pages;
    },
    formatNumber(n) {
      const num = Number(n);

      if (num >= 1_000_000) {
        return (num / 1_000_000).toFixed(1).replace(/\.0$/, "") + "M";
      } else if (num >= 1_000) {
        return (num / 1_000).toFixed(1).replace(/\.0$/, "") + "K";
      }

      return num.toString();
    },
    formatFullNumber(n) {
      return Number(n).toLocaleString("en-US"); // e.g. 1,234,567
    },
  };
}

function entriesApp() {
  return {
    forms: [],
    entries: [],
    totalEntries: 0,
    formId: null, // currently selected form
    currentPage: 1,
    pageSize: 10,
    filterStatus: "all",
    searchQuery: "",
    onlyFavorites: false,
    setError: false,
    loading: false,

    async fetchForms() {
      this.loading = true;
      try {
        const res = await fetch(`${femSettings.restUrl}fem/v1/forms`, {
          headers: {
            "X-WP-Nonce": femSettings.nonce,
          },
        });
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        const data = await res.json();
        this.forms = data;
        this.loading = false;
      } catch (error) {
        this.setError = true;
        this.loading = false;
        // FEM_I18N: Use translatable string
        console.error(femStrings.fetchFormsError, error);
      }
    },

    async fetchEntries() {
      if (!this.formId) return;

      const query = new URLSearchParams({
        form_id: this.formId,
        per_page: this.pageSize,
        page: this.currentPage,
        ...(this.filterStatus !== "all"
          ? {
              status: this.filterStatus,
            }
          : {}),
        ...(this.searchQuery
          ? {
              search: this.searchQuery,
            }
          : {}),
      });

      try {
        const res = await fetch(
          `${femSettings.restUrl}fem/v1/entries?${query}`,
          {
            headers: {
              "X-WP-Nonce": femSettings.nonce,
            },
          }
        );
        if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
        const data = await res.json();

        this.entries = JSON.parse(JSON.stringify(data.entries || []));
        this.totalEntries = data.total || 0;
      } catch (error) {
        // FEM_I18N: Use translatable string
        console.error(femStrings.fetchEntriesError, error);
      }
    },

    handleSearchInput: _.debounce(function () {
      this.currentPage = 1;
      this.fetchEntries();
    }, 500),

    handleFilterChange() {
      this.currentPage = 1;
      this.fetchEntries();
    },

    changePage(page) {
      this.currentPage = page;
      this.fetchEntries();
    },
  };
}

function toastHandler() {
  return {
    message: "",
    type: "success",
    visible: false,
    init() {
      window.addEventListener("toast", (e) => {
        this.message = e.detail.message;
        this.type = e.detail.type || "success";
        this.visible = true;

        setTimeout(() => (this.visible = false), 3000);
      });
    },
  };
}

function settingsForm() {
  return {
    isSaving: false,
    message: "",

    async saveSettings() {
      this.isSaving = true;
      this.message = "";

      const form = document.querySelector("#fem-settings-form");
      const formData = new FormData(form);

      formData.delete("option_page");
      formData.delete("action");
      formData.delete("_wpnonce");
      formData.delete("_wp_http_referer");

      formData.append("action", "fem_save_settings");
      formData.append("_wpnonce", femSettings.nonce);

      try {
        const res = await fetch(ajaxurl, {
          method: "POST",
          body: formData,
        });

        const data = await res.json();

        if (data.success) {
          window.dispatchEvent(
            new CustomEvent("toast", {
              detail: {
                // FEM_I18N: Use translatable string
                message: femStrings.settingsSavedSuccess,
                type: "success",
              },
            })
          );
        } else {
          window.dispatchEvent(
            new CustomEvent("toast", {
              detail: {
                // FEM_I18N: Use translatable string
                message:
                  femStrings.saveFailed + " " + (data.data?.message || ""),
                type: "error",
              },
            })
          );
        }
      } catch (err) {
        console.error(err);
        // FEM_I18N: Use translatable string
        this.message = femStrings.unexpectedError;
      }

      this.isSaving = false;
    },
  };
}


function exportSettings() {
  return {
    // Reactive State
    forms: [],
    selectedFormId: "",
    fields: [],
    excludedFields: [],
    dateFrom: "",
    dateTo: "",
    isExporting: false,
    exportJobId: null,
    exportProgress: 0,
    exportInterval: null,
    processedCount: 0,
    totalEntries: 0,
    isExportComplete: false,

    // UI State
    showProgressModal: false,
    errorMessage: "",
    isOntheGoExport: false,
    formTitle: "",

    init() {
      console.log("Alpine exportSettings initialized");
      this.fetchForms();

      // Check for a saved job on page load
      const savedJobId = localStorage.getItem("fem_export_job_id");
      if (savedJobId) {
        this.exportJobId = savedJobId;
        this.isExporting = true;
        this.startPolling();
        // CHANGED: Automatically show the modal on reload for better UX.
        // this.showProgressModal = true;
        console.log(`Resuming export job: ${this.exportJobId}`);
      }
    },

    // Fetches forms from the REST API
    async fetchForms() {
      try {
        const res = await fetch(`${femSettings.restUrl}fem/v1/forms`, {
          headers: { "X-WP-Nonce": femSettings.nonce },
        });
        const data = await res.json();
        this.forms = data;
      } catch (e) {
        console.error("Error fetching forms:", e);
      }
    },

    // Fetches form fields when a form is selected
    async fetchFormFields() {
      if (!this.selectedFormId) {
        this.fields = [];
        this.excludedFields = [];
        return;
      }

      this.errorMessage = "";
      try {
        const res = await fetch(
          `${femSettings.restUrl}fem/v1/forms/${this.selectedFormId}/fields`,
          {
            headers: { "X-WP-Nonce": femSettings.nonce },
          }
        );
        const data = await res.json();
        this.fields = data.fields;
        this.excludedFields = [];
      } catch (e) {
        console.error("Error fetching form fields:", e);
        this.errorMessage = "Failed to fetch form fields. Please try again.";
      }
    },

    // Initiates the async export job
    async exportAllBatchesAsync() {
      if (!this.selectedFormId) {
        this.errorMessage = "Please select a form before exporting.";
        return;
      }

      // CHANGED: Reset state from any previous completed job before starting a new one.
      this.resetExportState();
      this.isExportComplete = false;

      this.errorMessage = "";
      this.isExporting = true;
      this.exportProgress = 0;
      this.exportJobId = null;
      this.dateFrom = document.getElementById("fem_export_date_from").value;
      this.dateTo = document.getElementById("fem_export_date_to").value;


      const exportData = {
        form_id: this.selectedFormId,
        date_from: this.dateFrom,
        date_to: this.dateTo,
        exclude_fields: this.excludedFields,
      };

      try {
        const res = await fetch(`${femSettings.restUrl}fem/v1/export/start`, {
          method: "POST",
          headers: {
            "X-WP-Nonce": femSettings.nonce,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(exportData),
        });

        const contentType = res.headers.get("content-type");

        if (contentType.includes("text/csv")) {
          const text = await res.text();
          this.isOntheGoExport = true;

          if (text.startsWith("id,") && text.includes("\n")) {
            const blob = new Blob([text], { type: "text/csv" });
            const url = window.URL.createObjectURL(blob);

            const a = document.createElement("a");
            a.href = url;
            a.download = `fem-entries-${this.formTitle}-${Date.now()}.csv`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            this.exportProgress = 100;
            this.isExportComplete = true;
            return; // Done: no polling needed
          } else {
            throw new Error("Invalid CSV content.");
          }
        }

        const result = await res.json();

        if (res.ok && result.success) {
          this.exportJobId = result.job_id;
          localStorage.setItem("fem_export_job_id", this.exportJobId);
          this.startPolling();
        } else {
          throw new Error(result.message || "Failed to start export.");
        }
      } catch (e) {
        console.error("Export start error:", e);
        this.errorMessage = e.message;
        this.resetExportState();
      }
    },

    // Starts the polling for job progress
    startPolling() {
      if (this.exportInterval) clearInterval(this.exportInterval);

      this.exportInterval = setInterval(async () => {
        try {
          const res = await fetch(
            `${
              femSettings.restUrl
            }fem/v1/export/progress?job_id=${encodeURIComponent(
              this.exportJobId
            )}`,
            {
              headers: { "X-WP-Nonce": femSettings.nonce },
            }
          );
          const result = await res.json();

          if (!res.ok) {
            throw new Error(
              result.message || "Failed to fetch export progress."
            );
          }

          this.exportProgress = result.progress;
          this.processedCount = result.processed;
          this.totalEntries = result.total;

          if (result.status !== "complete" && result.status !== "failed") {
            this.isExporting = true;
          }

          if (result.status === "complete") {
            // CHANGED: Major logic change here. Do not reset the full state.
            // Just stop polling and set the completion flags.
            // The exportJobId is intentionally kept to allow re-download/delete.
            clearInterval(this.exportInterval);
            this.exportInterval = null;
            this.isExporting = false;
            this.isExportComplete = true;
            this.exportProgress = 100; // Ensure it shows 100%

            this.handleDownload(result.file_url); // Trigger the download

            this.errorMessage =
              "Export complete! Your download should start shortly.";
            this.showProgressModal = false; // Close modal on completion
          }

          if (result.status === "failed") {
            throw new Error(result.message || "Export job failed.");
          }
        } catch (e) {
          console.error("Progress polling failed:", e);
          this.errorMessage = e.message;
          this.resetExportState(); // Full reset is correct for a failure
          this.showProgressModal = false;
        }
      }, 3000); // Poll every 3 seconds
    },

    // Handles the file download
    handleDownload(fileUrl) {
      if (!this.exportJobId) {
        console.error("No export job ID found for download.");
        this.errorMessage = "Cannot download file: Export Job ID is missing.";
        return;
      }
      // This implementation is fine. It uses a dedicated endpoint which is good practice.
      const downloadUrl = `${
        femSettings.restUrl
      }fem/v1/export/download?job_id=${encodeURIComponent(this.exportJobId)}`;
      window.open(downloadUrl, "_blank");
    },

    // Resets the state variables. Called on new export, on failure, or after deletion.
    resetExportState() {
      if (this.exportInterval) {
        clearInterval(this.exportInterval);
        this.exportInterval = null;
      }
      this.isExporting = false;
      this.exportJobId = null;
      this.exportProgress = 0;
      this.processedCount = 0;
      this.totalEntries = 0;
      // Note: isExportComplete is NOT reset here. It's handled separately.
      localStorage.removeItem("fem_export_job_id");
    },

    showExportProgress() {
      this.showProgressModal = true;
    },

    closeProgressModal() {
      this.showProgressModal = false;
    },

    async deleteExportFile() {
      if (
        !confirm(
          "Are you sure you want to delete the export file? This action cannot be undone."
        )
      ) {
        return;
      }

      this.errorMessage = "";
      try {
        const res = await fetch(
          `${
            femSettings.restUrl
          }fem/v1/export/delete?job_id=${encodeURIComponent(this.exportJobId)}`,
          {
            method: "POST",
            headers: {
              "X-WP-Nonce": femSettings.nonce,
            },
          }
        );

        const result = await res.json();

        if (res.ok && result.success) {
          alert(result.message);
          this.isExportComplete = false;
          // This is a correct place to call resetExportState.
          this.resetExportState();
        } else {
          throw new Error(result.message || "Failed to delete the file.");
        }
      } catch (e) {
        console.error("Delete file error:", e);
        this.errorMessage = e.message;
      }
    },
  };
}

function migrationHandler() {
  return {
    totalEntries: 0,
    batchSize: 50,
    migrating: false,
    complete: false,
    progress: 0,
    log: [],
    pollInterval: null,

    migrated: 0,
    total: 0,
    estimatedTime: "",
    startTime: null,
    lastLoggedProgress: null,
    entryFetchStarted: false,

    // New flag to track ongoing migration even if not showing progress UI
    migrationInProgress: false,

    init() {
      // Load batch size from localStorage if you want to persist that too
      const savedBatch = localStorage.getItem("fem_batch_size");
      if (savedBatch) this.batchSize = parseInt(savedBatch, 10);

      // ✅ Prevent duplicate fetch
      if (!this.entryFetchStarted) {
        this.entryFetchStarted = true;

        fetch(`${femSettings.restUrl}fem/v1/legacy/source/count`, {
          headers: { "X-WP-Nonce": femSettings.nonce },
        })
          .then((res) => {
            if (!res.ok) throw new Error("Failed to fetch entry counts");
            return res.json();
          })
          .then((data) => {
            this.totalEntries = data.reduce(
              (sum, item) => sum + parseInt(item.entry_count),
              0
            );
            this.log.push(
              `📊 Found total ${this.totalEntries} entries to migrate`
            );
          })
          .catch((err) => {
            this.log.push(`⚠️ Error loading total entries: ${err.message}`);
            this.totalEntries = 0;
          });
      }

      // Check if migration was in progress before page reload
      const inProgress = localStorage.getItem("fem_migration_in_progress");
      if (inProgress === "true") {
        this.migrationInProgress = true;

        // Check current backend status once and decide whether to show progress UI
        this.checkProgress().then(() => {
          if (!this.complete) {
            this.migrating = false; // Not actively polling yet
          }
        });
      }
    },

    async startMigration() {
      if (this.totalEntries === 0) {
        this.log.push("⚠️ No entries to migrate.");
        return;
      }

      this.migrating = true;
      this.complete = false;
      this.log = [];
      this.progress = 0;
      this.startTime = Date.now();
      this.lastLoggedProgress = null;

      this.log.push(`🔁 Starting migration with batch size: ${this.batchSize}`);

      localStorage.setItem("fem_migration_in_progress", "true");
      localStorage.setItem("fem_batch_size", this.batchSize);

      try {
        const triggerRes = await fetch(
          `${femSettings.restUrl}fem/v1/migration/trigger`,
          {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "X-WP-Nonce": femSettings.nonce,
            },
            body: JSON.stringify({ batch_size: this.batchSize }),
          }
        );
        const triggerData = await triggerRes.json();

        if (!triggerData.success) {
          this.migrating = false;
          localStorage.setItem("fem_migration_in_progress", "false");
          this.log.push(
            `❌ Failed to start migration: ${
              triggerData.message || "Unknown error."
            }`
          );
          return;
        }

        this.log.push("🚀 Migration triggered successfully.");

        // Start polling progress every 2 seconds
        this.pollInterval = setInterval(() => this.checkProgress(), 2000);
      } catch (error) {
        this.migrating = false;
        localStorage.setItem("fem_migration_in_progress", "false");
        this.log.push(`❌ Error starting migration: ${error.message}`);
      }
    },

    async checkProgress() {
      try {
        const res = await fetch(
          `${femSettings.restUrl}fem/v1/migration/progress`,
          {
            headers: { "X-WP-Nonce": femSettings.nonce },
          }
        );
        const data = await res.json();

        const migrated = data.migrated || 0;
        const total = data.total || 1;
        const progress = Math.floor((migrated / total) * 100);

        this.migrated = migrated;
        this.total = total;
        this.progress = progress;

        if (!this.startTime) this.startTime = Date.now();
        const elapsedSec = (Date.now() - this.startTime) / 1000;
        const rate = migrated / data.eta;
        const remaining = total - migrated;
        const estimatedSec = remaining / (rate || 1);
        this.estimatedTime = this.formatTime(estimatedSec);

        if (progress !== this.lastLoggedProgress) {
          this.log.push(`📊 Progress: ${progress}% (${migrated} / ${total})`);
          this.lastLoggedProgress = progress;
        }

        if (data.complete || progress >= 100) {
          clearInterval(this.pollInterval);
          this.pollInterval = null;
          this.migrating = false;
          this.complete = true;
          this.progress = 100;
          this.log.push("🎉 Migration complete!");
          localStorage.setItem("fem_migration_in_progress", "false");
          this.migrationInProgress = false;
        }
      } catch (error) {
        this.log.push(`❌ Error checking progress: ${error.message}`);
      }
    },

    formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}m ${secs}s`;
    },

    stopMigration() {
      if (this.pollInterval) {
        clearInterval(this.pollInterval);
        this.pollInterval = null;
      }
      this.migrating = false;
      this.complete = false;
      this.progress = 0;
      this.log.push("🛑 Migration stopped.");
      localStorage.setItem("fem_migration_in_progress", "false");
      this.migrationInProgress = false;
    },

    // New method: Show migration progress UI when user clicks "See Progress"
    seeProgress() {
      this.migrating = true;
      this.migrationInProgress = true;

      // Start polling progress every 2 seconds
      if (!this.pollInterval) {
        this.pollInterval = setInterval(() => this.checkProgress(), 2000);
      }
    },
  };
}

function customColumnsForm() {
  return {
    // State to hold forms, fields, and user selections
    forms: [],
    allFields: {}, // { form_id: [field1, field2] }
    selectedColumns: {}, // { form_id: [selectedFieldKeys] }
    loadingSettings: {
      forms: false,
      fields: false,
      save: false,
    },

    // Initialization method
    init() {
      this.fetchForms();

      // Load existing options from PHP variable if available
      if (
        typeof femSettings !== "undefined" &&
        femSettings.initialColumns
      ) {
        this.selectedColumns = femSettings.initialColumns;
        console.log(this.selectedColumns);
      }
    },

    // Fetches all available forms from the REST API
    async fetchForms() {
      this.loadingSettings.forms = true;
      try {
        const response = await fetch(`${femSettings.restUrl}fem/v1/forms`, {
          headers: { "X-WP-Nonce": femSettings.nonce },
        });
        const data = await response.json();
        this.forms = data;

        // Initialize selectedColumns for any new form if not already set
        this.forms.forEach((f) => {
          if (!this.selectedColumns[f.form_id]) {
            this.selectedColumns[f.form_id] = [];
          }
        });

        // This ensures the fields are loaded for each form found.
        // Using Promise.all to fetch fields for all forms concurrently
        // for better performance.
        const fieldFetches = this.forms.map((form) =>
          this.fetchFields(form.form_id)
        );
        await Promise.all(fieldFetches);
      } catch (error) {
        console.error("Error fetching forms or fields:", error);
      } finally {
        this.loadingSettings.forms = false;
      }
    },

    // Fetches fields for a specific form
    async fetchFields(form_id) {
      if (!form_id) return;

      // Mark a specific form's fields as loadingSettings
      this.loadingSettings.fields = true;
      try {
        const response = await fetch(
          `${femSettings.restUrl}fem/v1/forms/${form_id}/fields`,
          {
            headers: { "X-WP-Nonce": femSettings.nonce },
          }
        );
        const data = await response.json();
        this.allFields[form_id] = data.entry_schema;
      } catch (error) {
        console.error(`Error fetching fields for form ${form_id}:`, error);
        this.allFields[form_id] = [];
      } finally {
        // Re-evaluate if all fields have been fetched
        this.loadingSettings.fields = false;
      }
    },
  };
}
